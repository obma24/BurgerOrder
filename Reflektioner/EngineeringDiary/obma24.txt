Engineering Diary (Individual Assignment):
Name: Obada Marawi 
(obma24)

Week 1:
This week, we received our assignment to create a hamburger ordering system that allows users to place orders, customize their hamburgers, add items to their cart, and either remove items or send the order to the kitchen via a kitchen client. We decided to use Git as our version control system, which is an easy collaboration among team members. I started by creating a Git account and setting up a repository. Initially, I found it challenging to adapt, especially with understanding of Git commands and version control concepts. However, I quickly learned to navigate the platform and began writing code and pushing updates to the repository. Setting up the repository was straightforward and provided a clear structure for our work.

Challenges Faced: The main challenge was familiarizing myself with Git. I struggled with understanding branches and merge conflicts initially, which caused some delays in our progress.

Reflections: By the end of the week, I recognized the importance of using branches to manage changes effectively. I learned to resolve merge conflicts by checking the differences between branches before merging. This experience highlighted the necessity of regularly committing changes and pulling updates from the team repository to avoid large, conflicting changes later on. Moving forward, I plan to encourage the team to make smaller, more frequent commits to reduce conflicts.

During the week, I also began to think about and discuss the project structure. I thought carefully about how to organize it and how to divide tasks according to each team member's strengths and weaknesses. I have a strong ability to learn quickly, so I focused on researching how databases operate and familiarizing myself with Flask, which is essential for our project’s backend.

Week 2:
In week 1, I dedicated a lot of time to learning by watching tutorial videos and asking questions within the group. I set up the foundation of our hamburger ordering system by creating two separate Flask applications: one for the customer interface (app.py) and another for the kitchen staff (kitchen.py). The goal was to allow customers to add hamburgers to a shopping cart, send their order, and let the kitchen handle the processing.

My first task was to create two distinct Flask servers that operate on different ports. The customer's server allows users to add and remove products from their cart and send their order to the kitchen. I visualized this process by likening it to ordering at McDonald's, where customers interact with a large screen to customize their orders, which are then displayed in the kitchen for staff preparation. After setting up the Flask framework, I began with simple endpoints to display the home page and handle both POST and GET requests.

Challenges Faced & Reflections: One challenge was ensuring the servers could operate concurrently without issues. Setting up the endpoints required careful attention to detail to handle the requests properly. While setting up the two Flask servers, I faced issues with configuring them to run concurrently. After testing and adjusting the configurations, I ensured both servers operated on separate ports and communicated correctly. This process taught me how to troubleshoot web server configurations and reinforced the importance of carefully planning communication between microservices.

Week 3:
As I was still acclimating to the technologies involved, I collaborated with my group to determine how we would structure our files. We decided to have two containers: BurgerOrderer and KitchenView. Each container would require its own Dockerfile. Given my limited knowledge about Docker at the time, I sought resources online and watched instructional videos to educate myself.

Once I implemented Docker, I encountered several challenges, particularly in setting up the Docker environment. Initially, the Flask applications couldn't communicate with one another due to network configuration issues. I resolved this by creating a docker-compose.yaml file, ensuring that both BurgerOrderer and KitchenView could run simultaneously and communicate through the correct ports.

Challenges Faced & Reflections: The main challenge was figuring out how to get both containers to communicate effectively. There were moments when the applications wouldn't connect, leading to frustration. This experience taught me the importance of thorough testing and debugging. I learned to break down the problem into manageable parts and tackle each issue systematically. One significant challenge was configuring Docker Compose for multiple services. The containers couldn't communicate at first due to incorrect network settings. I resolved this by properly configuring the network in docker-compose.yaml and assigning static IP addresses to each container. Afterward, I tested the setup by running both containers and ensuring they could exchange data through the correct ports.. For future projects, I plan to spend more time understanding Docker networking in advance. 

Week 4:
As a group, we decided to utilize a NoSQL database, specifically MongoDB, for our burger application. I set up a connection to MongoDB in a new file called MenuStore_db.py, where I created collections for our burgers and customizations. To maintain organization, I dropped any existing collections to prevent outdated information from cluttering our database.

I populated these collections with various burgers and customization options using the insert_many method. This approach enables easy management and updates of our menu. In app.py, I connected to the same MongoDB database and developed functions to retrieve burgers and customizations as needed. This ensures that when users visit the ordering page, the app pulls the latest options directly from the database, providing a seamless and up-to-date user experience.

Challenges Faced & Reflections: One challenge was ensuring the database was set up correctly and that the Flask app could access it without issues. I initially struggled with correctly formatting data and handling errors. This week highlighted the importance of database management in application development. I learned how critical it is to keep data organized and accessible. Moving forward, I want to improve my understanding of database querying and indexing to optimize performance. I learned how crucial it is to properly structure the database for efficient querying and data retrieval. While initially setting up the database, I faced issues with slow queries. By indexing key fields such as burger name, I improved performance. Moving forward, I plan to optimize database queries further and explore more advanced MongoDB features.

Week 5:
During the coding process, I encountered several issues. First, the shopping cart would disappear every time the page was refreshed. To debug this, I used Flask’s built-in debugging mode, which provides detailed error messages and live reloading. This helped me trace the issue to session handling. After reviewing the session configuration in Flask, I realized that sessions were not persisting because Flask requires a secret_key to manage sessions securely. The solution was to add a secret_key in the Flask application, which allowed Flask to properly manage sessions and persist the shopping cart data across page reloads. After making this change, I tested it by adding items to the cart, refreshing the page, and confirming that the cart retained its data.

Another issue I faced was that the POST requests to the kitchen service were failing due to an incorrect URL. To debug this, I used browser developer tools, specifically the Network tab, to inspect the exact requests being sent. I reviewed the URLs and response codes, which helped me identify that the wrong URL was being used when the application ran inside Docker. I solved this by adjusting the URL dynamically based on whether the application was running locally or in Docker. I tested the fix by running the application in both environments and ensuring the POST requests reached the kitchen service successfully.

Finally, Docker presented another challenge. The container wouldn’t start properly because the requirements.txt file was missing essential packages required for the Flask app. I used Docker’s logs to trace the exact error messages, which indicated missing modules. By updating the requirements.txt file to include all necessary dependencies, such as Flask and requests, I was able to get the Docker container to run correctly. Afterward, I tested the Docker setup by running the application using docker-compose up --build and confirmed that all dependencies were correctly installed and the application ran without issues.

Reflection: These challenges helped me understand the importance of session management in web applications and the need to account for different environments (local vs. Docker). Using Flask’s debug mode and browser developer tools taught me how to efficiently diagnose issues with session handling and API requests. Additionally, maintaining an accurate requirements.txt file proved critical for ensuring that Docker containers run smoothly. Moving forward, I plan to improve error handling for environment-specific configurations and continue refining my Docker setup for easier deployment.
