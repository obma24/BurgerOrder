Engineering Diary (Individual Assignment):
Name: Obada Marawi 
(obma24)

Week 1: Setting up Github (The start of the project)
This week, we received our assignment to create a hamburger ordering system that allows users to place orders, customize their hamburgers, add items to their cart, and either remove items or send the order to the kitchen via a kitchen client. We decided to use Git as our version control system, which is an easy collaboration among team members. I started by creating a Git account and setting up a repository. Initially, I found it challenging to adapt, especially with understanding of Git commands and version control concepts. However, I quickly learned to navigate the platform and began writing code and pushing updates to the repository. Setting up the repository was straightforward and provided a clear structure for our work.

Challenges Faced & Reflections:: The main challenge was familiarizing myself with Git. I struggled with understanding branches and merge conflicts initially, which caused some delays in our progress. By the end of the week, I recognized the importance of using branches to manage changes effectively. I learned to resolve merge conflicts by checking the differences between branches before merging. This experience highlighted the necessity of regularly committing changes and pulling updates from the team repository to avoid large, conflicting changes later on. Moving forward, I plan to encourage the team to make smaller, more frequent commits to reduce conflicts.

During the week, I also began to think about and discuss the project structure. I thought carefully about how to organize it and how to divide tasks according to each team member's strengths and weaknesses. I have a strong ability to learn quickly, so I focused on researching how databases operate and familiarizing myself with Flask, which is essential for our project’s backend.

Week 2: Learning Flask and Setting Up the App
In week 1, I dedicated a lot of time to learning by watching tutorial videos and asking questions within the group. I set up the foundation of our hamburger ordering system by creating two separate Flask applications: one for the customer interface (app.py) and another for the kitchen staff (kitchen.py). The goal was to allow customers to add hamburgers to a shopping cart, send their order, and let the kitchen handle the processing.

My first task was to create two distinct Flask servers that operate on different ports. The customer's server allows users to add and remove products from their cart and send their order to the kitchen. I visualized this process by likening it to ordering at McDonald's, where customers interact with a large screen to customize their orders, which are then displayed in the kitchen for staff preparation. After setting up the Flask framework, I began with simple endpoints to display the home page and handle both POST and GET requests.

Challenges Faced & Reflections: One challenge was ensuring the servers could operate concurrently without issues. Setting up the endpoints required careful attention to detail to handle the requests properly. While setting up the two Flask servers, I faced issues with configuring them to run concurrently. After testing and adjusting the configurations, I ensured both servers operated on separate ports and communicated correctly. This process taught me how to troubleshoot web server configurations and reinforced the importance of carefully planning communication between microservices.

Week 3: Setting up Docker
As I was still acclimating to the technologies involved, I collaborated with my group to determine how we would structure our files. We decided to have two containers: BurgerOrderer and KitchenView. Each container would require its own Dockerfile. Given my limited knowledge about Docker at the time, I sought resources online and watched instructional videos to educate myself. Once I implemented Docker, I encountered several challenges, particularly in setting up the Docker environment. Initially, the Flask applications couldn't communicate with one another due to network configuration issues. I resolved this by creating a docker-compose.yaml file, ensuring that both BurgerOrderer and KitchenView could run simultaneously and communicate through the correct ports.

Challenges Faced & Reflections: The main challenge was figuring out how to get both containers to communicate effectively. There were moments when the applications wouldn't connect, leading to frustration. This experience taught me the importance of thorough testing and debugging. I learned to break down the problem into manageable parts and tackle each issue systematically. One significant challenge was configuring Docker Compose for multiple services. The containers couldn't communicate at first due to incorrect network settings. I resolved this by properly configuring the network in docker-compose.yaml and assigning static IP addresses to each container. Afterward, I tested the setup by running both containers and ensuring they could exchange data through the correct ports.. For future projects, I plan to spend more time understanding Docker networking in advance. 

Week 4: Starting with NoSQL database
As a group, we decided to utilize a NoSQL database, specifically MongoDB, for our burger application. I set up a connection to MongoDB in a new file called MenuStore_db.py, where I created collections for our burgers and customizations. To maintain organization, I dropped any existing collections to prevent outdated information from cluttering our database. I populated these collections with various burgers and customization options using the insert_many method. This approach enables easy management and updates of our menu. In app.py, I connected to the same MongoDB database and developed functions to retrieve burgers and customizations as needed. This ensures that when users visit the ordering page, the app pulls the latest options directly from the database, providing a seamless and up-to-date user experience.

Challenges Faced & Reflections: One challenge was ensuring the database was set up correctly and that the Flask app could access it without issues. I initially struggled with correctly formatting data and handling errors. This week highlighted the importance of database management in application development. I learned how critical it is to keep data organized and accessible. Moving forward, I want to improve my understanding of database querying and indexing to optimize performance. I learned how crucial it is to properly structure the database for efficient querying and data retrieval. While initially setting up the database, I faced issues with slow queries. By indexing key fields such as burger name, I improved performance. Moving forward, I plan to optimize database queries further and explore more advanced MongoDB features.

Week 5: Issues with the Shopping Cart and Docker
During the coding process, I encountered several issues. First, the shopping cart would disappear every time the page was refreshed. To debug this, I used Flask’s built-in debugging mode, which provides detailed error messages and live reloading. This helped me trace the issue to session handling. After reviewing the session configuration in Flask, I realized that sessions were not persisting because Flask requires a secret_key to manage sessions securely. The solution was to add a secret_key in the Flask application, which allowed Flask to properly manage sessions and persist the shopping cart data across page reloads. After making this change, I tested it by adding items to the cart, refreshing the page, and confirming that the cart retained its data.

Another issue I faced was that the POST requests to the kitchen service were failing due to an incorrect URL. To debug this, I used browser developer tools, specifically the Network tab, to inspect the exact requests being sent. I reviewed the URLs and response codes, which helped me identify that the wrong URL was being used when the application ran inside Docker. I solved this by adjusting the URL dynamically based on whether the application was running locally or in Docker. I tested the fix by running the application in both environments and ensuring the POST requests reached the kitchen service successfully.

Finally, Docker presented another challenge. The container wouldn’t start properly because the requirements.txt file was missing essential packages required for the Flask app. I used Docker’s logs to trace the exact error messages, which indicated missing modules. By updating the requirements.txt file to include all necessary dependencies, such as Flask and requests, I was able to get the Docker container to run correctly. Afterward, I tested the Docker setup by running the application using docker-compose up --build and confirmed that all dependencies were correctly installed and the application ran without issues.

Reflection: These challenges helped me understand the importance of session management in web applications and the need to account for different environments (local vs. Docker). Using Flask’s debug mode and browser developer tools taught me how to efficiently diagnose issues with session handling and API requests. Additionally, maintaining an accurate requirements.txt file proved critical for ensuring that Docker containers run smoothly. Moving forward, I plan to improve error handling for environment-specific configurations and continue refining my Docker setup for easier deployment.

Week 6: Debugging Database Issues and Docker Configuration
I encountered an issue with the database when the menu items failed to display in the Burger Orderer application. To solve this problem, I began by debugging the code. My initial approach involved inserting print statements within the database-related functions to check whether the data was being fetched correctly. If the print output appeared in the application logs, I knew the data was being retrieved; if not, it indicated a problem with the database connection or the query.

Through this process, I identified that the issue was not with the code logic itself but with the application’s setup. Specifically, I realized the problem was related to the Docker configuration. The database wasn’t being properly connected in the Docker environment, which meant that the data wasn’t being pulled into the application. To solve this, I examined the project’s Dockerfile and discovered that the database initialization script (MenuStore_db.py) wasn’t being executed before the Flask application (app.py) started. This was crucial because the database needed to be populated with menu items before the app could display them.

Originally, the Dockerfile contained the following command to start the application:

CMD ["python", "app.py"]

I modified it to:
CMD ["sh", "-c", "python MenuStore_db.py && python app.py"]

By making this change, I ensured that the MenuStore_db.py script, which initializes the menu data in MongoDB, runs before the Flask application starts. This guaranteed that the application had access to the correct data as soon as it launched.

Reflections: This debugging session taught me the importance of properly sequencing tasks in Docker containers, especially when dealing with database initialization. I also gained a deeper understanding of how Docker Compose and Dockerfiles interact to manage dependencies between different parts of the system. Moving forward, I plan to establish better debugging practices and ensure that all necessary services are correctly set up before the application runs.

Overall Reflection:
This project has been a fantastic learning journey for me! I’ve really dug deep into software engineering and development, especially while working as part of a team. From getting our Flask applications up and running to managing Docker containers, I’ve faced some interesting challenges that helped me grow my problem-solving skills. One of the biggest takeaways for me was understanding session management. It’s super important for keeping things smooth for users, especially in an ordering system like ours. Debugging issues with sessions made me appreciate how crucial it is to keep data intact when users refresh their pages. I learned to track down problems quickly and come up with solid fixes. 

Working with Docker was another eye-opener. It taught me a lot about running multiple services and ensuring they communicate properly. I had to pay close attention to network settings and dependencies, which was a bit tricky at first. But once I figured out how to use Docker Compose and create effective Dockerfiles, it felt great to see everything working together seamlessly! I also learned how important it is to have an accurate requirements.txt file to make sure all the necessary packages are included for smooth deployments. Looking ahead, I see some exciting opportunities to improve. I want to dive more into automated testing and brenching to make sure future projects are robust from the start. I also plan to explore more advanced Docker techniques, like health checks and multi-stage builds, to make our applications even better. Additionally, I’d love to enhance my skills in database optimization, particularly in querying and indexing, so we can handle larger datasets more efficiently.

Overall, this experience has shown me that challenges are just part of the journey. Each obstacle I faced taught me something new, and I learned the importance of breaking down problems and using the right tools to find solutions. As I move forward, I’ll carry these lessons with me, and I’m excited to keep improving my technical skills and tackle future projects with even more confidence.

Questions & Answers to Myself:
1. How often do you update your engineering diary?
I have made it a point to update my engineering diary regularly throughout the project. Each day, I documented what I worked on, the challenges I encountered, and the solutions I implemented. This consistent practice has provided me with a clear overview of the project's progress and my personal learning journey.

2. What content do you include in your engineering diary?
In my engineering diary, I reflect on various aspects such as collaboration, configuration management, implementation, documentation, testing, and debugging. I have noted specific challenges, such as conflicts that arose during branching, and how we addressed these through code reviews and merging strategies. Additionally, I have recorded areas for improvement and ideas for enhancing my contributions in future projects, demonstrating a proactive approach to my development.

3. How did you document a debugging session?
During a debugging session where we encountered issues with order handling, I strategically set breakpoints in the code to analyze how data was being transmitted from the BurgerOrderer to the KitchenView. By monitoring the variables at each step, I identified that the data format was incorrect, which resulted in the orders not displaying correctly. After modifying the format, I successfully resolved the issue and documented a detailed account of the entire process in my diary. This reflection not only helped me understand the debugging process better but also served as a valuable resource for similar challenges in the future.
