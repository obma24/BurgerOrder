Engineering Diary (Individual Assignment):
Name: Obada Marawi 
(obma24)

Week 1: Setting up Github (The start of the project)
This week, we received our assignment to create a hamburger ordering system that allows users to place orders, customize their hamburgers, add items to their cart, and either remove items or send the order to the kitchen via a kitchen client. We decided to use Git as our version control system, which is an easy collaboration among team members. I started by creating a Git account and setting up a repository. Initially, I found it challenging to adapt, especially with understanding of Git commands and version control concepts. However, I quickly learned to navigate the platform and began writing code and pushing updates to the repository. Setting up the repository was straightforward and provided a clear structure for our work.

Challenges Faced & Reflections:: The main challenge was familiarizing myself with Git. I struggled with understanding branches and merge conflicts initially, which caused some delays in our progress. By the end of the week, I recognized the importance of using branches to manage changes effectively. I learned to resolve merge conflicts by checking the differences between branches before merging. This experience highlighted the necessity of regularly committing changes and pulling updates from the team repository to avoid large, conflicting changes later on. Moving forward, I plan to encourage the team to make smaller, more frequent commits to reduce conflicts. During the week, I also began to think about and discuss the project structure. I thought carefully about how to organize it and how to divide tasks according to each team member's strengths and weaknesses. I have a strong ability to learn quickly, so I focused on researching how databases operate and familiarizing myself with Flask, which is essential for our project’s backend.

Week 2: Learning Flask and Setting Up the App
In week 1, I dedicated a lot of time to learning by watching tutorial videos and asking questions within the group. I set up the foundation of our hamburger ordering system by creating two separate Flask applications: one for the customer interface (app.py) and another for the kitchen staff (kitchen.py). The goal was to allow customers to add hamburgers to a shopping cart, send their order, and let the kitchen handle the processing. My first task was to create two distinct Flask servers that operate on different ports. The customer's server allows users to add and remove products from their cart and send their order to the kitchen. I visualized this process by likening it to ordering at McDonald's, where customers interact with a large screen to customize their orders, which are then displayed in the kitchen for staff preparation. After setting up the Flask framework, I began with simple endpoints to display the home page and handle both POST and GET requests.

Challenges Faced & Reflections: One challenge was ensuring the servers could operate concurrently without issues. Setting up the endpoints required careful attention to detail to handle the requests properly. While setting up the two Flask servers, I faced issues with configuring them to run concurrently. After testing and adjusting the configurations, I ensured both servers operated on separate ports and communicated correctly. This process taught me how to troubleshoot web server configurations and reinforced the importance of carefully planning communication between microservices.

Week 3: Setting up Docker
As I was still acclimating to the technologies involved, I collaborated with my group to determine how we would structure our files. We decided to have two containers: BurgerOrderer and KitchenView. Each container would require its own Dockerfile. Given my limited knowledge about Docker at the time, I sought resources online and watched instructional videos to educate myself. Once I implemented Docker, I encountered several challenges, particularly in setting up the Docker environment. Initially, the Flask applications couldn't communicate with one another due to network configuration issues. So i created a docker-compose.yaml file, ensuring that both BurgerOrderer and KitchenView could run simultaneously and communicate through the correct ports. 

In my debug session, I started by observing the port variables and network configurations in both the Dockerfiles and the docker-compose.yaml file. In each Dockerfile, I checked the “EXPOSE” lines, where BurgerOrderer exposed port “5000" and "KitchenView" exposed port "5001", but the containers still weren't connecting. To troubleshoot, I added print statements in both "app.py" and "kitchen.py" to confirm they were running and listening on the expected ports. The outputs showed that both applications were up, but the connection between them was still failing. I moved to the "docker-compose.yaml" file to adjust the network settings. I observed the "ports" mapping and initially set "network_mode: bridge" to enable shared network access. I noticed that "ports" were mapped correctly (5000:5000 and 5001:5001), but communication still wasn’t happening. I then updated the "networks" section, explicitly defining a network named "burger_network". This allowed each service to connect by its container name. I observed the environment variables "FLASK_APP_HOST" and "FLASK_APP_PORT" to ensure they were consistent in both files, pointing "BurgerOrderer" to "http://kitchen:5001" and "KitchenView" to "http://burgerorderer:5000". On re-running, I checked logs using "docker-compose logs" and confirmed the ports and network configurations were aligned. At this point, the containers were able to communicate over the expected ports, resolving the initial connectivity issue.

Challenges Faced & Reflections: The main challenge was figuring out how to get both containers to communicate effectively. There were moments when the applications wouldn't connect, leading to frustration. This experience taught me the importance of thorough testing and debugging. I learned to break down the problem into manageable parts and tackle each issue systematically. One significant challenge was configuring Docker Compose for multiple services. The containers couldn't communicate at first due to incorrect network settings. I resolved this by properly configuring the network in docker-compose.yaml and assigning static IP addresses to each container. Afterward, I tested the setup by running both containers and ensuring they could exchange data through the correct ports.. For future projects, I plan to spend more time understanding Docker networking in advance. 

Week 4: Starting with NoSQL database
As a group, we decided to utilize a NoSQL database, specifically MongoDB, for our burger application. I set up a connection to MongoDB in a new file called MenuStore_db.py, where I created collections for our burgers and customizations. To maintain organization, I dropped any existing collections to prevent outdated information from cluttering our database.

I populated these collections with various burgers and customization options using the insert_many method. This approach enables easy management and updates of our menu. In app.py, I connected to the same MongoDB database and developed functions to retrieve burgers and customizations as needed. This ensures that when users visit the ordering page, the app pulls the latest options directly from the database, providing a seamless and up-to-date user experience.

Challenges Faced & Reflections: One challenge was ensuring the database was set up correctly and that the Flask app could access it without issues. I initially struggled with correctly formatting data and handling errors. This week highlighted the importance of database management in application development. I learned how critical it is to keep data organized and accessible. Moving forward, I want to improve my understanding of database querying and indexing to optimize performance. I learned how crucial it is to properly structure the database for efficient querying and data retrieval. While initially setting up the database, I faced issues with slow queries. By indexing key fields such as burger name, I improved performance. Moving forward, I plan to optimize database queries further and explore more advanced MongoDB features.

Week 5: Issues with the Shopping Cart and Docker
During the coding process, I encountered several issues. First, the shopping cart would disappear every time the page was refreshed. To debug this, I used Flask’s built-in debugging mode, which provides detailed error messages and live reloading. This helped me trace the issue to session handling. After reviewing the session configuration in Flask, I realized that sessions were not persisting because Flask requires a secret_key to manage sessions securely. The solution was to add a secret_key in the Flask application, which allowed Flask to properly manage sessions and persist the shopping cart data across page reloads. After making this change, I tested it by adding items to the cart, refreshing the page, and confirming that the cart retained its data.

Another issue I faced was that the POST requests to the kitchen service were failing due to an incorrect URL. To debug this, I used browser developer tools, specifically the Network tab, to inspect the exact requests being sent. I reviewed the URLs and response codes, which helped me identify that the wrong URL was being used when the application ran inside Docker. I solved this by adjusting the URL dynamically based on whether the application was running locally or in Docker. I tested the fix by running the application in both environments and ensuring the POST requests reached the kitchen service successfully.

Finally, Docker presented another challenge. The container wouldn’t start properly because the requirements.txt file was missing essential packages required for the Flask app. I used Docker’s logs to trace the exact error messages, which indicated missing modules. By updating the requirements.txt file to include all necessary dependencies, such as Flask and requests, I was able to get the Docker container to run correctly. Afterward, I tested the Docker setup by running the application using docker-compose up --build and confirmed that all dependencies were correctly installed and the application ran without issues.

So in my debugging session, I focused on several key variables related to session handling in Flask to track down the disappearing shopping cart issue. Using Flask’s built-in debugging mode, I observed the session-related variables, such as "session['cart']", which was intended to store the shopping cart data. Initially, this variable was empty after each page refresh, indicating that the session data wasn’t being retained as expected. I examined the value of "session['cart']" at various points in the code, particularly after adding items to the cart and immediately following page reloads. In the process, I also checked the Flask "request" object to confirm that the "POST" requests correctly sent the cart data to the session. Additionally, I reviewed the value of "app.config['SECRET_KEY']", which was missing before setting it up, leading to sessions being reset. By adding a "SECRET_KEY" configuration in Flask, I could observe a consistent value in "session['cart']" across reloads. After making this change, I tested each action (adding and removing items, reloading the page) to ensure the "session['cart']" variable maintained the correct list of items, confirming that the cart persisted successfully.

Reflection: These challenges helped me understand the importance of session management in web applications and the need to account for different environments (local vs. Docker). Using Flask’s debug mode and browser developer tools taught me how to efficiently diagnose issues with session handling and API requests. Additionally, maintaining an accurate requirements.txt file proved critical for ensuring that Docker containers run smoothly. Moving forward, I plan to improve error handling for environment-specific configurations and continue refining my Docker setup for easier deployment.

Week 6: Debugging Database Issues and Docker Configuration
I encountered an issue with the database when the menu items failed to display in the Burger Orderer application. To solve this problem, I began by debugging the code. My initial approach involved inserting print statements within the database-related functions to check whether the data was being fetched correctly. If the print output appeared in the application logs, I knew the data was being retrieved; if not, it indicated a problem with the database connection or the query. Through this process, I identified that the issue was not with the code logic itself but with the application’s setup. Specifically, I realized the problem was related to the Docker configuration. The database wasn’t being properly connected in the Docker environment, which meant that the data wasn’t being pulled into the application.To solve this, I examined the project’s Dockerfile and discovered that the database initialization script (MenuStore_db.py) wasn’t being executed before the Flask application (app.py) started. This was crucial because the database needed to be populated with menu items before the app could display them.

Originally, the Dockerfile contained the following command to start the application:

CMD ["python", "app.py"]

I modified it to:
CMD ["sh", "-c", "python MenuStore_db.py && python app.py"]

By making this change, I ensured that the MenuStore_db.py script, which initializes the menu data in MongoDB, runs before the Flask application starts. This guaranteed that the application had access to the correct data as soon as it launched.

Reflections: This debugging session taught me the importance of properly sequencing tasks in Docker containers, especially when dealing with database initialization. I also gained a deeper understanding of how Docker Compose and Dockerfiles interact to manage dependencies between different parts of the system. Moving forward, I plan to establish better debugging practices and ensure that all necessary services are correctly set up before the application runs.

So in my debugging session, I examined specific variables and lines related to the database connection and Docker configuration. To confirm whether the database data was fetched correctly, I inserted print statements at key points in the "MenuStore_db.py" script and in the database-related functions in "app.py". I checked variables like "menu_items" to see if it held the expected data from MongoDB. If the print statements showed the correct data in the application logs, I knew the data retrieval was successful; if they didn’t appear, it suggested an issue with the database connection or the Docker configuration. I also monitored the Docker container logs to observe any errors related to MongoDB connections or missing dependencies. Specifically, I looked at logs where "menu_items" should be populated. When I noticed that the "menu_items" variable was empty, I confirmed that the database script ("MenuStore_db.py") wasn’t running before "app.py". After adjusting the Docker "CMD" line to execute "MenuStore_db.py" first, I observed that "menu_items" successfully held the correct data, indicating the database was now properly initialized before the app started.

Feedback for incomplete assignment
We got Fx for pytest, because we missed to do it, we thought that testing was just all about we manually testing if the functions work without any automated testing, but after we published the project and the other assignments, we got feedback to redo it, and so what we did is learned how to pytest and so we tested some functionalities for the main file “app.py” for BurgerOrderer and KitchenView, and we got some errors and fails, so we as a team met up and together tried to know the reason for the fails and error and fixed it so we passed the tests. We ran tests on a range of scenarios, like accessing the order page, customizing and adding burgers, and finalizing the order. For the kitchen view, we started by making sure the kitchen page loaded correctly, with "Kitchen" visible on the screen. Next, we verified that adding a new order worked as expected and that it appeared in the order list. We also tested the ability to retrieve current orders, ensuring they returned as a list. Finally, we canceled an order to confirm it was removed and that no orders remained afterward.

During my debugging session for the BurgerOrderer and KitchenView applications, I focused on observing several key variables and their values throughout the testing process. In the "test_app.py" file (BurgerOrderer), I began by examining the response status codes from various endpoints. For instance, in the "test_order_page" function, I checked that the response status code was "200", indicating a successful page load. I also looked for the presence of specific items in the response data, confirming that "b'Cheeseburger'" and "b'Extra Cheese'" were included, which validated that the correct content was displayed. When testing the cart functionality in the "test_add_to_cart" method, I monitored the session data after posting a burger to the cart. I asserted that "len(sess['cart'])" was "1", verifying that one item was correctly added. Additionally, I checked that "sess['cart'][0]['burger']" equaled "'Cheeseburger'", and confirmed that the customizations were properly stored with "assert 'Extra Cheese' in sess['cart'][0]['customizations']". In "test_remove_from_cart", I observed the status code of the response after the removal action. I again accessed the session data and ensured that "len(sess['cart'])" returned "0", confirming that the cart was empty after removing the burger. For the order placement in "test_place_order", I verified that the response status code was "302", indicating a redirect. I then checked the session to ensure that "len(sess['cart'])" was "0" after placing the order and that "'confirmed_order'" existed in the session.

In "test2.app.py"file (KitchenView), I concentrated on the state of the orders before and after testing order functionalities. In the "test_kitchen_page", I verified that "b'Kitchen'" was present in the response data to confirm the kitchen page loaded correctly. In the "test_new_order" method, I constructed a "new_order" dictionary with "{'item': 'Burger', 'quantity': 2}" and checked the response status after posting it. Afterward, I retrieved the current orders with a GET request and validated that "response.json" matched "[new_order]", confirming the order was successfully added. In the "test_cancel_order", I examined the orders after posting a new order. I printed the value of "response.json" to the console to observe the current state of orders after the cancellation, checking that it returned "[]", indicating that no orders remained. Throughout the session, I specifically focused on the status codes, response data, session variables, and the content of "response.json" to track the application’s behavior and ensure that it operated as expected.


Overall Reflection:
This project has been a fantastic learning journey for me! I’ve really dug deep into software engineering and development, especially while working as part of a team. From getting our Flask applications up and running to managing Docker containers, I’ve faced some interesting challenges that helped me grow my problem-solving skills. One of the biggest takeaways for me was understanding session management. It’s super important for keeping things smooth for users, especially in an ordering system like ours. Debugging issues with sessions made me appreciate how crucial it is to keep data intact when users refresh their pages. I learned to track down problems quickly and come up with solid fixes.

Working with Docker was another eye-opener. It taught me a lot about running multiple services and ensuring they communicate properly. I had to pay close attention to network settings and dependencies, which was a bit tricky at first. But once I figured out how to use Docker Compose and create effective Dockerfiles, it felt great to see everything working together seamlessly! I also learned how important it is to have an accurate requirements.txt file to make sure all the necessary packages are included for smooth deployments. I also missed to start with testing (pytest) early in the development, which is something I and my team are going to look up to in the future.

Looking ahead, I see some exciting opportunities to improve. I want to dive more into automated testing to make sure future projects are robust from the start. I also plan to explore more advanced Docker techniques, like health checks and multi-stage builds, to make our applications even better. Additionally, I’d love to enhance my skills in database optimization, particularly in querying and indexing, so we can handle larger datasets more efficiently. Overall, this experience has shown me that challenges are just part of the journey. Each obstacle I faced taught me something new, and I learned the importance of breaking down problems and using the right tools to find solutions. As I move forward, I’ll carry these lessons with me, and I’m excited to keep improving my technical skills and tackle future projects with even more confidence.

Questions & Answers to Myself:
1. How often do you update your engineering diary?
I have made it a point to update my engineering diary regularly throughout the project. Each time I implemented a new thing, everyday I wrote a little bit so I could remember so by the end of each week I documented what I worked on, the challenges I encountered, and the solutions I implemented. This consistent practice has provided me with a clear overview of the project's progress and my personal learning journey.

2. What content do you include in your engineering diary?
In my engineering diary, I reflect on various aspects such as collaboration, configuration management, implementation, documentation, testing, and debugging. I have noted specific challenges, such as conflicts that arose during branching, and how we addressed these through code reviews and merging strategies. Additionally, I have recorded areas for improvement and ideas for enhancing my contributions in future projects, demonstrating a proactive approach to my development.

3. How did you document a debugging session?
During a debugging session where we encountered issues with order handling, I strategically set breakpoints in the code to analyze how data was being transmitted from the BurgerOrderer to the KitchenView. By monitoring the variables at each step, I identified that the data format was incorrect, which resulted in the orders not displaying correctly. After modifying the format, I successfully resolved the issue and documented a detailed account of the entire process in my diary. This reflection not only helped me understand the debugging process better but also served as a valuable resource for similar challenges in the future.
